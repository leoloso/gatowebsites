---
title: Persisted Queries
description: "Provide multiple GraphQL endpoints to target different users and applications."
order: 2250
---

Use GraphQL queries to create pre-defined endpoints as in REST, obtaining the benefits from both APIs.

## Description

With **REST**, you create multiple endpoints, each returning a pre-defined set of data.

| Advantages | Disadvantages |
| --- | --- |
| ‚úÖ It's simple | ‚ùå It's tedious to create all the endpoints |
| ‚úÖ Accessed via `GET` or `POST` | ‚ùå A project may face bottlenecks waiting for endpoints to be ready |
| ‚úÖ Can be cached on the server or CDN | ‚ùå Producing documentation is mandatory |
| ‚úÖ It's secure: only intended data is exposed | ‚ùå It can be slow (mainly for mobile apps), since the application may need several requests to retrieve all the data |

With **GraphQL**, you provide any query to a single endpoint, which returns exactly the requested data.

| Advantages | Disadvantages |
| --- | --- |
| ‚úÖ No under/over fetching of data | ‚ùå Accessed only via `POST` |
| ‚úÖ It can be fast, since all data is retrieved in a single request | ‚ùå It can't be cached on the server or CDN, making it slower and more expensive than it could be |
| ‚úÖ It enables rapid iteration of the project | ‚ùå It may require to reinvent the wheel, such as uploading files or caching |
| ‚úÖ It can be self-documented | ‚ùå Must deal with additional complexities, such as the N+1 problem |
| ‚úÖ It provides an editor for the query (GraphiQL) that simplifies the task | &nbsp; |

**Persisted queries** combine these 2 approaches together:

- It uses GraphQL to create and resolve queries
- But instead of exposing a single endpoint, it exposes every pre-defined query under its own endpoint

Hence, we obtain multiple endpoints with predefined data, as in REST, but these are created using GraphQL, obtaining the advantages from each and avoiding their disadvantages:

<table>
<thead>
<tr>
    <th>Advantages</th>
    <th>Disadvantages</th>
</tr>
</thead>
<tbody>
<tr>
    <td>‚úÖ Accessed via <code>GET</code> or <code>POST</code></td>
    <td><s>‚ùå It's tedious to create all the endpoints</s></td>
</tr>
<tr>
    <td>‚úÖ Can be cached on the server or CDN</td>
    <td><s>‚ùå A project may face bottlenecks waiting for endpoints to be ready</s></td>
</tr>
<tr>
    <td>‚úÖ It's secure: only intended data is exposed</td>
    <td><s>‚ùå Producing documentation is mandatory</s></td>
</tr>
<tr>
    <td>‚úÖ No under/over fetching of data</td>
    <td><s>‚ùå It can be slow (mainly for mobile apps), since the application may need several requests to retrieve all the data</s></td>
</tr>
<tr>
    <td>‚úÖ It can be fast, since all data is retrieved in a single request</td>
    <td><s>‚ùå Accessed only via <code>POST</code></s></td>
</tr>
<tr>
    <td>‚úÖ It enables rapid iteration of the project</td>
    <td><s>‚ùå It can't be cached on the server or CDN, making it slower and more expensive than it could be</s></td>
</tr>
<tr>
    <td>‚úÖ It can be self-documented</td>
    <td><s>‚ùå It may require to reinvent the wheel , such asuploading files or caching</s></td>
</tr>
<tr>
    <td>‚úÖ It provides an editor for the query (GraphiQL) that simplifies the task</td>
    <td><s>‚ùå Must deal with additional complexities, such as the N+1 problem</s> üëàüèª this issue is [resolved by the underlying engine](https://graphql-by-pop.com/docs/architecture/suppressing-n-plus-one-problem.html)</td>
</tr>
</tbody>
</table>

![Persisted query editor](/assets/guides/upstream/persisted-query.png "Persisted query editor")

## Executing the Persisted Query

Once the persisted query is published, we can execute it via its permalink.

The persisted query can be executed directly in the browser, since it is accessed via `GET`, and we will obtain the requested data, in JSON format:

![Executing a persisted in the browser](/assets/guides/upstream/persisted-query-execution.png)

## Creating a Persisted Query

Clicking on the Persisted Queries link in the menu, it displays the list of all the created persisted queries:

<Image
  src="/assets/guides/upstream/persisted-queries-page.png"
  width="1024"
  height="940"
  alt="Persisted queries with description"
  caption="Persisted queries with description"
/>

A persisted query is a custom post type (CPT). To create a new persisted query, click on button "Add New GraphQL persisted query", which will open the WordPress editor:

![Creating a new Persisted Query](/assets/guides/upstream/new-persisted-query.png)

The main input is the GraphiQL client, which comes with the Explorer by default. Clicking on the fields on the left side panel adds them to the query, and clicking on the "Run" button executes the query:

![GraphiQL Explorer](/assets/guides/downstream/clients/graphiql-explorer.gif "GraphiQL Explorer")

When the query is ready, publish it, and its permalink becomes its endpoint. The link to the endpoint (and to the source) is shown on the "Persisted Query Endpoint Overview" sidebar panel:

![Persisted Query Endpoint Overview](/assets/guides/upstream/persisted-query-endpoint-overview.png)

Appending `?view=source` to the permalink, it will show the persisted query and its configuration (as long as the user is logged-in and the user role has access to it):

![Persisted query source](/assets/guides/upstream/persisted-query-source.png)

By default, the persisted query's endpoint has path `/graphql-query/`, and this value is configurable through the Settings:

<Image
  src="/assets/guides/upstream/settings-persisted-queries.png"
  width="1024"
  height="940"
  alt="Persisted query Settings"
  caption="Persisted query Settings"
/>

### Schema configuration

Defining what elements the schema contains, and what access will users have to it, is defined in the schema configuration.

So we must create a create a schema configuration, and then select it from the dropdown:

![Selecting the schema configuration](/assets/guides/upstream/select-schema-configuration.png "Selecting the schema configuration")

### Organizing Persisted Queries by Category

On the sidebar panel "Endpoint categories" we can add categories to help manage the Persisted Query:

![Endpoint categories when editing a Persisted Query](/assets/guides/upstream/graphql-persisted-query-editor-with-categories.png)

For instance, we can create categories to manage endpoints by client, application, or any other required piece of information:

![List of endpoint categories](/assets/guides/upstream/graphql-endpoint-categories.png "List of endpoint categories")

On the list of Persisted Queries, we can visualize their categories and, clicking on any category link, or using the filter at the top, will only display all entries for that category:

![List of Persisted Queries with their categories](/assets/guides/upstream/graphql-persisted-queries-with-categories.png)

### Private persisted queries

By setting the status of the Persisted Query as `private`, the endpoint can only be accessed by the admin user. This prevents our data from being unintentionally shared with users who should not have access to the data.

For instance, we can create private Persisted Queries that help manage the application, such as retrieving data to create reports with our metrics.

![Private Persisted Query](/assets/guides/upstream/private-persisted-query.png)

### Password-protected persisted queries

If we create a Persisted Query for a specific client, we can assign a password to it, to provide an additional level of security that only that client will access the endpoint.

![Password-protected Persisted Query](/assets/guides/upstream/password-protected-persisted-query.png)

When first accessing a password-protected persisted query, we encounter a screen requesting the password:

![Password-protected Persisted Query: First access](/assets/guides/upstream/password-protected-persisted-query-unauthorized.png)

Once the password is provided and validated, only then the user will access the intended endpoint.

### Making the persisted query dynamic via URL params

The value for each variable can be set via a URL param (with the variable name) when executing the persisted query. If option "Do URL params override variables?" is enabled, then the URL param will take priority. Otherwise, the value defined in the variables dictionary will take priority (if any).

For instance, in this query, the number of results is controlled via variable `$limit`, with a default value of 3:

![Using variables in persisted query](/assets/guides/upstream/new-persisted-query-variables.png)

When executing this persisted query, passing `?limit=5` will execute the query returning 5 results instead:

![Overriding value for variables in persisted query](/assets/guides/upstream/executing-persisted-query-variables.png)

