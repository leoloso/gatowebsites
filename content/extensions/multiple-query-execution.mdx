---
title: Multiple Query Execution
description: "Combine multiple queries into a single query, sharing state across them and executing them in the requested order."
# image: /assets/product-logos/GatoGraphQL-suki-extension.png
order: 0
# order: 2200
featured: true
category: 'Schema functionality'
relatedGuide: {
  topic: schema,
  slug: executing-multiple-queries-concurrently
}
# shopProductTestModeURL: https://shop.gatographql.com/checkout/buy/9de8afdb-84d2-48f6-bde7-e0f96c81a0da
# shopProductURL: https://shop.gatographql.com/checkout/buy/f7bde59b-c180-4aff-99df-7561d0bbed3b
# productPrices:
# - 24.99
# - 49.99
# - 99.99
# bundles:
# - automated-content-translation-and-sync-for-wordpress-multisite
# - better-wordpress-webhooks
# - easy-wordpress-bulk-transform-and-update
# - private-graphql-server-for-wordpress
# - responsible-wordpress-public-api
# - selective-content-import-export-and-sync-for-wordpress
# - simplest-wordpress-content-translation
# - tailored-wordpress-automator
# - unhindered-wordpress-email-notifications
# - versatile-wordpress-request-api
---

Multiple query execution combines multiple queries into a single query, executing them in the same requested order, while allowing them to communicate state with each other via dynamic variables.

```graphql
query GetLoggedInUserName {
  me {
    name @export(as: $loggedInUserName)
  }
}

query FindPosts @depends(on: "GetLoggedInUserName") {
  posts(filter: { search: $loggedInUserName }) {
    id
    title
  }
}
```

This feature offers several benefits:

- **Performance**: Instead of executing a query against the GraphQL server, then wait for its response, and then use that result to execute another query, combine the queries together into one and execute them in a single request, thus avoiding the latency from the multiple HTTP connections.
- **Functionality**: Adapt field values as needed. Query some value from the database in one operation, and transform it and inject it into another field on another operation.
- **Modularity**: Manage your GraphQL queries into atomic operations (or logical units) that depend on each other, and that can be conditionally executed based on the result from a previous operation.

