---
title: "üë®üèª‚Äçüîß Gato GraphQL v7.0: Headless WordPress without WordPress"
seoTitle: "üë®üèª‚Äçüîß Gato GraphQL introduces Headless WordPress without WordPress"
description: 'With the latest version, it is possible to execute Gato GraphQL queries without initializing WordPress!'
seoDescription: 'With the latest version, it is possible to execute Gato GraphQL queries without initializing WordPress!'
publishedAt: '2024-11-06 09:00:00'
author: 'Leonardo Losoviz'
authorImg: '/images/leo-avatar.jpg'
tags:
  - product update
---

Ever since the Matt Mullenweg vs WPEngine debacle, I've noticed more and more people (in Reddit and elsewhere) asking for alternatives to WordPress, not necessarily to switch away from WordPress (at least not immediately), but to understand what options they have, and how painful would a potential migration be. They want to know how to hedge their bets.

For these folks who are working with headless WordPress, Gato GraphQL has a cool new feature: **Headless WordPress without WordPress**.

This post explains all about it, describes the architecture that makes it possible, and shows a video demonstrating it.

## Gato GraphQL as a standalone PHP app

Gato GraphQL has been built using standalone PHP components, managed via Composer, in such a way that **all the PHP components making up the GraphQL server do not depend on WordPress!**

This gives us the first benefit:

**1. The GraphQL server can run as a standalone PHP application**, and you can include it within PHP application, WordPress or else.

## Migrating away from WordPress

The GraphQL schema contains fields to fetch WordPress data: posts, users, comments, tags, categories, etc.

The PHP resolvers's code fetching WordPress data depend on WordPress, and that code cannot run on a non-WordPress app.

However, Gato GraphQL has these resolvers implemented via 2 packages:

1. A non-WordPress one, containing all generic code, and
2. A WordPress-specific one, containing the actual invocations to WordPress methods that satisfy that resolver

For instance, the logic for fetching posts is composed of:

1. The [`Root.posts` field](https://github.com/GatoGraphQL/GatoGraphQL/blob/6.0.2/layers/CMSSchema/packages/posts/src/FieldResolvers/ObjectType/AbstractPostObjectTypeFieldResolver.php#L200), which lives on the generic [posts package](https://github.com/GatoGraphQL/GatoGraphQL/blob/6.0.2/layers/CMSSchema/packages/posts)
2. Its resolution for WordPress via the [`get_posts` method](https://github.com/GatoGraphQL/GatoGraphQL/blob/6.0.2/layers/CMSSchema/packages/customposts-wp/src/TypeAPIs/AbstractCustomPostTypeAPI.php#L108), which lives on the WordPress-specific [posts-wp package](https://github.com/GatoGraphQL/GatoGraphQL/blob/6.0.2/layers/CMSSchema/packages/posts-wp).

The code split between non-WordPress/WordPress packages is something around 80/20%%, meaning that **80% of the code is reusable with another framework/CMS**, and only **20% of the code would need to be reimplemented**.

Moreover, all functionality in Gato GraphQL is shipped via modules, and modules can be enabled/disabled at will.

![Schema modules](/assets/guides/downstream/schema-type-modules.png "Schema modules")

<Banner type="info">

This feature was implemented for security purposes: If you don't need to expose user data in your public API, then you can disable the Users module, and the corresponding fields (such as `Root.users`) will never be added to the schema.

</Banner>

**Modules are directly mapped to underlying PHP packages.** When running Gato GraphQL as a standalone app, we can then selectively load those modules/packages that we need.

If you application exposes data for posts, categories and tags only, only the `posts-wp`, `categories-wp`, and `tags-wp` packages need to be loaded.

Then, when migrating away from WordPress, only those 3 packages would need to be reimplemented for the new framework/CMS, and nothing else.

This gives us the second benefit:

**2. You can use headless WordPress today**, knowing that down the road you can **migrate your application to another framework or CMS with minimal effort**.

## Transitioning to Gato GraphQL from another API

If you are already doing headless WordPress, chances are that your app is using either the WP REST API or WPGraphQL.

It is not difficult to have Gato GraphQL take their place. Then, you are still able to migrate your current headless WordPress app away from WordPress.

These 2 steps would then be needed:

1. Transition from WP REST API or WPGraphQL to Gato GraphQL
2. Reimplement the WordPress-specific packages to load needed data (as explained earlier on)

Let's see how the API transition can be done.

### WP REST API to Gato GraphQL persisted queries

With the [Persisted Queries](/extensions/persisted-queries) extension you can publish REST-like endpoints, composed using GraphQL.

Then, for each of the REST endpoints in your application, you can create a corresponding persisted query endpoint that retrieves the same data, and inject those URLs in your app.

For instance, the following GraphQL query can replace REST endpoint `/wp-json/wp/v2/posts/`:

```graphql

```

Thanks to the [API hierarchy](/guides/use/creating-an-api-hierarchy), the persisted query be published under path `/graphql-query/wp/v2/posts/`, making it easy to replace endpoints.

### WPGraphQL to Gato GraphQL

## Demo: Gato GraphQL as a standalone PHP app

```graphql
# File retrieve-github-artifacts.gql

query RetrieveProxyArtifactDownloadURLs(
  $repoOwner: String!
  $repoProject: String!
  $perPage: Int = 1
  $artifactName: String = ""
) {
  githubAccessToken: _env(name: "GITHUB_ACCESS_TOKEN")
    @remove

  # Create the authorization header to send to GitHub
  authorizationHeader: _sprintf(
    string: "Bearer %s"
    values: [$__githubAccessToken]
  )
    @remove

  # Create the authorization header to send to GitHub
  githubRequestHeaders: _echo(
    value: [
      { name: "Accept", value: "application/vnd.github+json" }
      { name: "Authorization", value: $__authorizationHeader }
    ]
  )
    @remove
    @export(as: "githubRequestHeaders")

  githubAPIEndpoint: _sprintf(
    string: "https://api.github.com/repos/%s/%s/actions/artifacts?per_page=%s&name=%s"
    values: [$repoOwner, $repoProject, $perPage, $artifactName]
  )

  # Use the field from "Send HTTP Request Fields" to connect to GitHub
  gitHubArtifactData: _sendJSONObjectItemHTTPRequest(
    input: {
      url: $__githubAPIEndpoint
      options: { headers: $__githubRequestHeaders }
    }
  )
    @remove

  # Finally just extract the URL from within each "artifacts" item
  gitHubProxyArtifactDownloadURLs: _objectProperty(
    object: $__gitHubArtifactData
    by: { key: "artifacts" }
  )
    @underEachArrayItem(passValueOnwardsAs: "artifactItem")
      @applyField(
        name: "_objectProperty"
        arguments: { object: $artifactItem, by: { key: "archive_download_url" } }
        setResultInResponse: true
      )
    @export(as: "gitHubProxyArtifactDownloadURLs")
}

query CreateHTTPRequestInputs
  @depends(on: "RetrieveProxyArtifactDownloadURLs")
{
  httpRequestInputs: _echo(value: $gitHubProxyArtifactDownloadURLs)
    @underEachArrayItem(passValueOnwardsAs: "url")
      @applyField(
        name: "_objectAddEntry"
        arguments: {
          object: {
            options: { headers: $githubRequestHeaders, allowRedirects: null }
          }
          key: "url"
          value: $url
        }
        setResultInResponse: true
      )
    @export(as: "httpRequestInputs")
    @remove
}

query RetrieveActualArtifactDownloadURLs
  @depends(on: "CreateHTTPRequestInputs")
{
  _sendHTTPRequests(inputs: $httpRequestInputs) {
    artifactDownloadURL: header(name: "Location")
      @export(as: "artifactDownloadURLs", type: LIST)
  }
}

query PrintSpaceSeparatedArtifactDownloadURLs
  @depends(on: "RetrieveActualArtifactDownloadURLs")
{
  spaceSeparatedArtifactDownloadURLs: _arrayJoin(
    array: $artifactDownloadURLs
    separator: " "
  )
}
```

```bash
# I have my GitHub Access token under environment variable ${GITHUB_ACCESS_TOKEN}
php retrieve-github-artifacts.php \
  | jq --color-output
```

<div className="aspect-video">
  <iframe
    className="w-full h-full"
    src="https://www.youtube.com/embed/GZt-93oDtQc"
    title=" Headless WordPress without Wordpress demo: Executing GraphQL query"
    width="768"
    height="432"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
    allowFullScreen
  >
  </iframe>
</div>

```bash
GITHUB_ARTIFACT_URLS=$(php retrieve-github-artifacts.php \
  | grep -E -o '"spaceSeparatedArtifactDownloadURLs\":"(.*)"' \
  | cut -d':' -f2- | cut -d'"' -f2- | rev | cut -d'"' -f2- | rev \
  | sed 's/\\\//\//g')
wp plugin install ${GITHUB_ARTIFACT_URLS} --force --activate
```

```php
<?php
// File retrieve-github-artifacts.php

declare(strict_types=1);

use GraphQLByPoP\GraphQLServer\Server\StandaloneGraphQLServer;
use PoP\Root\Container\ContainerCacheConfiguration;

// Load the GraphQL server via the standalone PHP components
require_once (__DIR__ . '/wordpress/wp-content/plugins/gatographql/vendor/scoper-autoload.php');

// Load the PRO extensions via the standalone PHP components
require_once (__DIR__ . '/wordpress/wp-content/plugins/gatographql-all-extensions-bundle/vendor/scoper-autoload.php');

// Modules required in the GraphQL query
$moduleClasses = [
  \PoPSchema\EnvironmentFields\Module::class,
  \PoPSchema\FunctionFields\Module::class,
  \GraphQLByPoP\ExportDirective\Module::class,
  \GraphQLByPoP\DependsOnOperationsDirective\Module::class,
  \GraphQLByPoP\RemoveDirective\Module::class,
  \PoPSchema\ApplyFieldDirective\Module::class,
  \PoPSchema\SendHTTPRequests\Module::class,
  \PoPSchema\ConditionalMetaDirectives\Module::class,
  \PoPSchema\DataIterationMetaDirectives\Module::class,
];

// Configure the modules
$moduleClassConfiguration = [
  \PoP\GraphQLParser\Module::class => [
    \PoP\GraphQLParser\Environment::ENABLE_MULTIPLE_QUERY_EXECUTION => true,
    \PoP\GraphQLParser\Environment::USE_LAST_OPERATION_IN_DOCUMENT_FOR_MULTIPLE_QUERY_EXECUTION_WHEN_OPERATION_NAME_NOT_PROVIDED => true,
    \PoP\GraphQLParser\Environment::ENABLE_RESOLVED_FIELD_VARIABLE_REFERENCES => true,
    \PoP\GraphQLParser\Environment::ENABLE_COMPOSABLE_DIRECTIVES => true,
  ],
  \PoPSchema\SendHTTPRequests\Module::class => [
    \PoPSchema\SendHTTPRequests\Environment::SEND_HTTP_REQUEST_URL_ENTRIES => [
      '#https://api.github.com/repos/(.*)#',
    ],
  ],
  \PoPSchema\EnvironmentFields\Module::class => [
    \PoPSchema\EnvironmentFields\Environment::ENVIRONMENT_VARIABLE_OR_PHP_CONSTANT_ENTRIES => [
      'GITHUB_ACCESS_TOKEN',
    ],
  ],
];

// Cache the schema to disk, to speed-up execution from the 2nd time onwards
$containerCacheConfiguration = new ContainerCacheConfiguration('MyGraphQLServer', true, 'retrieve-github-artifacts', __DIR__ . '/tmp');

// Initialize the server
$graphQLServer = new StandaloneGraphQLServer($moduleClasses, $moduleClassConfiguration, [], [], $containerCacheConfiguration);

/**
 * GraphQL query to execute, stored in its own .gql file
 *
 * @var string
 */
$query = file_get_contents(__DIR__ . '/retrieve-github-artifacts.gql');

// GraphQL variables
$variables = [
  'repoOwner' => 'GatoGraphQL',
  'repoProject' => 'GatoGraphQL',
  'perPage' => 3
];

// Execute the query
$response = $graphQLServer->execute(
  $query,
  $variables,
);

// Print the response
echo $response->getContent();
```